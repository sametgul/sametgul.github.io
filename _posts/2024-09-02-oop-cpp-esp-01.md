---
title: "Day 1 (2/2): Embedded Systems Implementation"
date: 2024-09-02 14:00:00 +0300
categories: ["Mastering OOP, C++, and Embedded Systems in 10 Days"]
tags: [oop, c++, esp32-s3, vscode, platformio]  # Updated tags to match project components
math: true
image: assets/img/espressif.png
---

**Welcome to Day 1 of My 10-Day Series on Mastering Object-Oriented Programming (OOP), C++, and Embedded Systems!**

Over the next 10 days, we'll dive deep into the world of OOP and C++. Each day is divided into two parts: the first focuses on core C++ concepts, while the second explores how to apply these concepts in embedded systems.

**Note:** This series is driven by my personal curiosity and learning journey. If you're completely new to OOP, you might find some parts challenging. However, if you have some foundational knowledge, you'll discover valuable insights, especially in how these principles are put to use in real-world embedded systems.

[Check out the full series here](../../categories/mastering-oop-c-and-embedded-systems-in-10-days/).

***In this post, we'll move on to Part 2 of Day 1: Creating a project and implementing the concepts in embedded systems, building upon the [Part 1 of Day 1](../oop-cpp-esp-00/).***

## **Creating a New Project in PlatformIO with Visual Studio Code**

Follow these steps to set up a new project using PlatformIO in Visual Studio Code:

1. **Open PlatformIO in Visual Studio Code:**
   - Launch Visual Studio Code.
   - Click on the PlatformIO icon in the left sidebar.
   - Click on "Create New Project" under PROJECT TASKS or click the home symbol at the bottom left to open "PIO Home."

2. **Start a New Project:**
   - Click the **“New Project”** button on the PlatformIO Home screen.

3. **Configure the New Project:**
   - **Name:** Enter a name for your project (e.g., `day1_oop_esp`).
   - **Board:** Select "Espressif ESP32-S3-DevkitC-1-N8".
   - **Framework:** Choose "Arduino".
   - **Location:** Choose a folder for saving the project files or leave it as the default.

4. **Create the Project:**
   - Click **“Finish”**. PlatformIO will create the project with the required folder structure and configuration files. This may take a moment, especially if it's your first time.

5. **Open the Main Project File:**
   - PlatformIO will open the project folder in the VS Code workspace. 
   - Navigate to the `src` folder and open `main.cpp` to start writing your code.
   - The `platformio.ini` file is also important for including libraries or configuring hardware settings.

6. **Upload Your Code or Use the Serial Monitor:**
   - To upload code, click the right arrow button at the bottom left or go to PROJECT TASKS and click **Upload** under **General**.
   - To open the serial monitor, click the plug symbol or go to PROJECT TASKS and click **Monitor** under **General**.

**Bonus: Install Required Drivers:**  
Most ESP32 boards use either the CP210x (Silicon Labs) or CH340 (WCH) USB-to-serial chips.  
  
- **Windows:** Check the Device Manager under Ports (COM & LPT) for "Silicon Labs CP210x USB to UART Bridge" or "USB-SERIAL CH340" with a COM port number.  
- **Linux:** Use the command `dmesg | grep tty` to check for connected devices.

Following these steps will set up a new project environment with all the necessary files and dependencies, allowing you to start developing and experimenting with embedded systems!

## RGB LED Control with OOP Concepts

We'll start with the basic LED control example and extend it to cover more OOP principles using an RGB LED. Here’s how you can do it:

### Step 1: Basic LED Class with Constructors and Destructors

Our development board has an RGB LED, but if we use the `digitalWrite()` command and treat it like a regular LED, it will behave as such. We'll create a base class for handling basic LED operations, and then extend it to handle RGB LEDs with more advanced features.

```cpp
#include <Arduino.h>

// Base class for a basic LED
class LED {
private:
    int pin;  // GPIO pin number for the LED

public:
    // Constructor: Initializes the LED with a specific pin
    LED(int ledPin) : pin(ledPin) {
        pinMode(pin, OUTPUT);
    }

    // Destructor: Cleanup if necessary (not required for this simple example)
    ~LED() {
        // No resources to clean up in this simple example
    }

    // Method to turn the LED on
    void turnOn() {
        digitalWrite(pin, HIGH);
    }

    // Method to turn the LED off
    void turnOff() {
        digitalWrite(pin, LOW);
    }
};
```

### Step 2: Inheritance - Creating an RGB LED Class

Now we’ll create a derived class, `RGBLED`, that inherits from the `LED` class and adds functionality for controlling an RGB LED.

```cpp
#include <Adafruit_NeoPixel.h>

#define PIN 48
#define NUMPIXELS 1
#define DELAYVAL 10

class RGBLED : public LED {
private:
    Adafruit_NeoPixel pixels;

public:
    // Constructor: Initialize base class and Adafruit NeoPixel object
    RGBLED(int ledPin) : LED(ledPin), pixels(NUMPIXELS, ledPin, NEO_GRB + NEO_KHZ800) {
        pixels.begin();
    }

    // Method to fade between colors
    void fadeColor(int steps = 100) {
        int colors[3][3] = {
            {255, 0, 0},   // Red
            {0, 255, 0},   // Green
            {0, 0, 255}    // Blue
        };

        for (int colorIndex = 0; colorIndex < 3; colorIndex++) {
            int nextColorIndex = (colorIndex + 1) % 3; 

            int startR = colors[colorIndex][0];
            int startG = colors[colorIndex][1];
            int startB = colors[colorIndex][2];
            int endR = colors[nextColorIndex][0];
            int endG = colors[nextColorIndex][1];
            int endB = colors[nextColorIndex][2];

            for (int i = 0; i <= steps; i++) {
                int r = startR + (endR - startR) * i / steps;
                int g = startG + (endG - startG) * i / steps;
                int b = startB + (endB - startB) * i / steps;

                pixels.setPixelColor(0, pixels.Color(r, g, b));
                pixels.show();
                delay(DELAYVAL);
            }
        }
    }

    // Override to turn the LED on with a green light
    void turnOn() override {
        pixels.setPixelColor(0, pixels.Color(0, 255, 0));  // Green color
        pixels.show();
    }

    // Override to turn the LED off with a red light
    void turnOff() override {
        pixels.setPixelColor(0, pixels.Color(255, 0, 0));  // Red color
        pixels.show();
    }
};
```

### Step 3: Polymorphism Example

Polymorphism allows us to use pointers or references to base class objects to interact with derived class objects. We'll show how this works using both upcasting and downcasting.

```cpp
LED* led;  // Base class pointer

void setup() {
    // Create an RGBLED object
    RGBLED rgbLed(PIN);

    // Upcast to base class pointer
    led = &rgbLed;

    // Demonstrate polymorphism with upcasting
    led->turnOn();   // Calls RGBLED's overridden turnOn() method
    delay(5000);
    led->turnOff();  // Calls RGBLED's overridden turnOff() method
    delay(5000);

    // Downcasting to derived class pointer
    RGBLED* rgbPtr = dynamic_cast<RGBLED*>(led);  // Attempt to cast to RGBLED type
    if (rgbPtr) {
        rgbPtr->fadeColor(); // Call the derived class-specific method
    }
}

void loop() {
    // The loop is intentionally left empty for this example.
}
```

### **Explanation of OOP Concepts:**

1. **Encapsulation:**
   - Encapsulation is achieved by making certain members private, like `pin` in the `LED` class and `pixels` in the `RGBLED` class. This practice hides the internal state and only allows controlled access through public methods like `turnOn`, `turnOff`, and `fadeColor`.

2. **Constructors and Destructors:**
   - **Constructors:** The `LED` class constructor initializes the GPIO pin for the LED as an output, setting up the hardware configuration. The `RGBLED` constructor extends this by also initializing the Adafruit NeoPixel library, which is necessary for RGB LED control.
   - **Destructors:** Destructors can be used in C++ for resource management and cleanup tasks when an object goes out of scope. Although they aren't strictly required in this example, they illustrate the structure needed for more complex scenarios.

3. **Abstraction:**
   - The `RGBLED` class abstracts the complexity of RGB LED control, providing a simplified interface that hides details such as the color management and direct interactions with the Adafruit NeoPixel library.

4. **Inheritance:**
   - The `RGBLED` class inherits from the `LED` class, allowing it to reuse and extend the functionality provided by the `LED` class, such as turning on/off the LED, while adding new features specific to RGB control like color fading.

5. **Polymorphism:**
   - **Method Overriding:** The `RGBLED` class overrides the base class methods (`turnOn` and `turnOff`) to provide behaviors specific to RGB LEDs, like setting a particular color when turning on.
   - **Dynamic Casting:** `dynamic_cast` is used to convert a base class pointer (`LED*`) to a derived class pointer (`RGBLED*`), allowing the program to call derived class methods specific to `RGBLED`, even when the pointer is initially of the base type.

#### **Explanation of Upcasting and Downcasting:**

1. **Upcasting:**
   - Upcasting happens when a base class pointer (`LED*`) is used to reference an object of the derived class (`RGBLED`). For example, `led` is a base class pointer that points to an `RGBLED` object. When `led->turnOn()` or `led->turnOff()` is called, the overridden methods in `RGBLED` are executed, demonstrating polymorphism. This shows how the base class pointer can call derived class methods due to the virtual function mechanism.

2. **Downcasting:**
   - Downcasting is the process of converting a base class pointer back to a derived class pointer. In the example, `dynamic_cast` is used to attempt converting the base class pointer `led` to a derived class pointer (`RGBLED*` stored in `rgbPtr`). If the cast is successful (checked using `if (rgbPtr)`), methods specific to the derived class, such as `fadeColor()`, can be called. This allows access to extended functionalities of the derived class.